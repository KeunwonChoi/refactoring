# 데이터 체계화

## 필드 자체 캡슐화 (Self Encapsulate Field)
- 필드용 읽기/쓰기 메소드를 만들어서 두 메서드만을 이용하여 필드에 접근하는 방법 (getter/setter)

~~~java
class IntRange {
    private int low;
    private int high;

    public IntRange(int low, int high) {
        this.low = low;
        this.high = high;
    }

    public boolean includes(int arg) {
        return arg >= low && arg <= high;
    }

    public void grow(int factor) {
        this.high = high * factor;
    }
}
~~~

~~~java
class IntRange {
    private int low;
    private int high;
    
    public IntRange(int low, int high) {
        initialize(low, high);
    }

    private void initialize(int low, int high) {
        this.low = low;
        this.high = high;
    }

    public boolean includes(int arg) {
        return arg >= low && arg <= high;
    }

    public void grow(int factor) {
        setHigh(high * factor);
    }

    public int getLow() {
        return low;
    }

    public void setLow(int low) {
        this.low = low;
    }

    public int getHigh() {
        return high;
    }

    public void setHigh(int high) {
        this.high = high;
    }
}
~~~


~~~java
class CappedRange extends IntRange {
    private int cap;

    public CappedRange(int low, int high, int cap) {
        super(low, high);
        this.cap = cap;
    }

    public int getCap() {
        return cap;
    }

    public int getHigh() {
        return Math.min(super.getHigh(), getCap());
    }
}

~~~

## 데이터 값을 객체로 전환 (Replace Data Value with Object)
- 데이터 항목에 데이터나 기능을 더 추가해야 할 때는 데이터 항목을 객체로 만드는 기법

###  리팩토링 전
~~~java
class Order {
    private String customer;

    public Order(String customer) {
        this.customer = customer;
    }

    public String getCustomer() {
        return customer;
    }

    public void setCustomer(String customer) {
        this.customer = customer;
    }
}

// Order 사용하는 일부 코드
private static int numberOfOrdersFor(List<Order> orderList, String customer) {
    int result = 0;

    for (Order order : orderList) {
        if (order.getCustomer().equals(customer)) { result++; }
    }
    return result;
}
~~~

### 리팩토링 후
~~~java
class Customer {
    private String name;

    public Customer(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

class Order {
    private Customer customer;

    public Order(String customer) {
        this.customer = customer;
    }

    public String getCustomerName() {
        return ccustomer.getName();
    }

    public void setCustomer(String arg) {
        this.customer = new Customer(arg);
    }
}
~~~

## 값을 참조로 전환 (Change Value to Reference)
- 클래스에 같은 인스턴스가 들어가 있어서 하나의 객체로 바꿔야 할 때 그 객체를 참조 객체로 전환하는 기법

### 리팩토링 전
~~~java
class Customer {
    private String name;

    public Customer(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

class Order {
    private Customer customer;

    public Order(String customer) {
        this.customer = customer;
    }

    public String getCustomerName() {
        return ccustomer.getName();
    }

    public void setCustomer(String arg) {
        this.customer = new Customer(arg);
    }
}

private static int numberOfOrdersFor(List<Order> orderList, String customer) {
    int result = 0;

    for (Order order : orderList) {
        if (order.getCustomerName().equals(customer)) { result++; }
    }
    return result;
}
~~~

### 리팩토링 후
~~~java
class Customer { 
    private String name;
    private static Map<String, Customer> instances = new HashMap<>();
    
    public static Customer getNamed(String name) {
        return (Customer) instances.get(name);
    }

    public static void loadCustomers() {
        new Customer("우리 렌터카").store();
        new Customer("커피 자판기 웅영업 협동조합").store();
        new Customer("삼천리 가스 공장").store();
    }

    private void store() {
        return instances.put(this.getName(), this);
    }
...

class Order {
    public Order(String customer) {
        customer = Customer.create(customer);
    }
...
~~~